<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>石子棋 - 在线博弈</title>
<style>
  :root {
    --size: 640px;
    --board-bg: #fff;
    --blue-piece: #2563eb;
    --blue-piece-dark: #1e3a8a;
    --black-piece: #111;
    --black-piece-dark: #000;
  }
  body {
    margin: 0;
    background: #f7f8fb;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Noto Sans CJK SC", "Microsoft YaHei", sans-serif;
    color: #111;
    display: grid;
    place-items: center;
    min-height: 100vh;
    padding: 16px;
  }
  .card {
    width: min(100%, 760px);
    background: #fff;
    border-radius: 18px;
    box-shadow: 0 10px 30px rgba(0,0,0,.08);
    padding: 16px;
  }
  .head {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    flex-wrap: wrap;
  }
  h1 {
    font-size: 20px;
    margin: 0;
  }
  .controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  button, select {
    padding: 10px 14px;
    border-radius: 12px;
    border: 1px solid #e5e7eb;
    background: #fff;
    font-weight: 600;
    cursor: pointer;
  }
  button.primary {
    background: #111;
    color: #fff;
    border-color: #111;
  }
  button:disabled {
    opacity: .5;
    cursor: not-allowed;
  }
  #status {
    margin: 10px 0 14px;
    font-size: 14px;
    color: #333;
  }
  .board-wrap {
    border: 1px solid #eceef5;
    border-radius: 12px;
    padding: 10px;
    background: #fbfbfd;
  }
  canvas {
    width: var(--size);
    height: var(--size);
    display: block;
    border-radius: 10px;
    background: var(--board-bg);
    margin: auto;
  }
  .legend {
    display: flex;
    gap: 14px;
    align-items: center;
    margin-top: 10px;
    font-size: 13px;
    color: #555;
  }
  .dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    display: inline-block;
    border: 2px solid #0002;
  }
  .blue {
    background: var(--blue-piece);
    border-color: var(--blue-piece-dark);
  }
  .black {
    background: var(--black-piece);
    border-color: var(--black-piece-dark);
  }
  .settings {
    margin-top: 10px;
    padding: 10px;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }
  .modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }
  .modal-content {
    background: #fff;
    padding: 20px;
    border-radius: 12px;
    text-align: center;
    max-width: 400px;
    width: 90%;
  }
  .modal-content h2 {
    margin: 0 0 20px;
    font-size: 24px;
    color: #111;
  }
  .modal-content button {
    margin: 0 10px;
  }
</style>
</head>
<body>
  <div class="card">
    <div class="head">
      <h1>石子棋（4×4格 · 5×5交点）</h1>
      <div class="controls">
        <button id="restart" class="primary">重新开始</button>
        <button id="undo">悔棋</button>
        <select id="mode" title="对弈模式">
          <option value="hvh">双人对战</option>
          <option value="blue-ai" selected>电脑执蓝</option>
          <option value="black-ai">电脑执黑</option>
        </select>
      </div>
    </div>
    <div id="status"></div>
    <div class="board-wrap">
      <canvas id="board" aria-label="石子棋棋盘" role="img"></canvas>
    </div>
    <div class="legend">
      <span><span class="dot blue"></span> 蓝子（默认在最上横线）</span>
      <span><span class="dot black"></span> 黑子（默认在最下横线）</span>
    </div>
    <div class="settings">
      <label>棋盘背景: <input type="color" id="board-bg" value="#ffffff"></label>
      <label>蓝子颜色: <input type="color" id="blue-piece" value="#2563eb"></label>
      <label>黑子颜色: <input type="color" id="black-piece" value="#111111"></label>
    </div>
  </div>
  <div id="modal" class="modal" style="display: none;">
    <div class="modal-content">
      <div id="modal-message"></div>
      <div id="modal-buttons"></div>
    </div>
  </div>

<script>
(function(){
  // ===== 棋盘参数 =====
  const GRID = 5;
  const CELL = 120;
  const PAD = 40;
  const SIZE = PAD*2 + CELL*(GRID-1);

  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.round(SIZE * DPR);
  canvas.height = Math.round(SIZE * DPR);
  canvas.style.width = SIZE + "px";
  canvas.style.height = SIZE + "px";
  ctx.scale(DPR, DPR);

  // UI 元素
  const modeSel = document.getElementById('mode');
  const statusEl = document.getElementById('status');
  const modal = document.getElementById('modal');
  const modalMessage = document.getElementById('modal-message');
  const modalButtons = document.getElementById('modal-buttons');
  const boardBgInput = document.getElementById('board-bg');
  const bluePieceInput = document.getElementById('blue-piece');
  const blackPieceInput = document.getElementById('black-piece');

  // 状态
  let board, turn, selected=null, legalMoves=[], lastMove=null, aiThinking=false, gameOver=false;
  const history = [];
  const transpositionTable = new Map(); // 置换表

  // 颜色设置
  function updateColors(){
    document.documentElement.style.setProperty('--board-bg', boardBgInput.value);
    document.documentElement.style.setProperty('--blue-piece', bluePieceInput.value);
    document.documentElement.style.setProperty('--blue-piece-dark', darkenColor(bluePieceInput.value, 0.7));
    document.documentElement.style.setProperty('--black-piece', blackPieceInput.value);
    document.documentElement.style.setProperty('--black-piece-dark', darkenColor(blackPieceInput.value, 0.7));
    draw();
  }
  function darkenColor(hex, factor){
    hex = hex.replace('#', '');
    const r = parseInt(hex.slice(0,2), 16);
    const g = parseInt(hex.slice(2,4), 16);
    const b = parseInt(hex.slice(4,6), 16);
    return `rgb(${Math.round(r*factor)},${Math.round(g*factor)},${Math.round(b*factor)})`;
  }
  boardBgInput.addEventListener('input', updateColors);
  bluePieceInput.addEventListener('input', updateColors);
  blackPieceInput.addEventListener('input', updateColors);

  // 工具函数
  const inBoard = (x,y)=> x>=0 && y>=0 && x<GRID && y<GRID;
  const get = (x,y)=> board[y][x];
  const set = (x,y,v)=> { board[y][x]=v; };
  const toPx = c => PAD + c*CELL;
  const clamp = (v,min,max)=> Math.max(min,Math.min(max,v));
  function fromPx(p){ return clamp(Math.round((p - PAD)/CELL), 0, GRID-1); }
  const neighbors = (x,y)=> [{x:x+1,y},{x:x-1,y},{x,y:y+1},{x,y:y-1}].filter(p=>inBoard(p.x,p.y));
  const computeLegal = (x,y)=> neighbors(x,y).filter(p=> get(p.x,p.y)===null );
  const cloneBoard = (bd)=> bd.map(r=>r.slice());
  const isAiTurn = ()=> (modeSel.value==='blue-ai' && turn==='blue') || (modeSel.value==='black-ai' && turn==='black');

  // 初始化
  function init(firstPlayer=null){
    board = Array.from({length:GRID},()=>Array(GRID).fill(null));
    for(let x=0;x<GRID;x++){
      board[0][x] = 'blue';
      board[GRID-1][x] = 'black';
    }
    turn = firstPlayer || 'blue';
    selected = null;
    legalMoves = [];
    lastMove = null;
    aiThinking = false;
    gameOver = false;
    history.length = 0;
    transpositionTable.clear();
    draw();
    updateStatus();
    maybeAiMove();
  }

  // 绘制
  function draw(){
    ctx.clearRect(0,0,SIZE,SIZE);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-bg');
    ctx.fillRect(0,0,SIZE,SIZE);
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    for(let i=0;i<GRID;i++){
      ctx.beginPath();
      ctx.moveTo(toPx(0), toPx(i));
      ctx.lineTo(toPx(GRID-1), toPx(i));
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(toPx(i), toPx(0));
      ctx.lineTo(toPx(i), toPx(GRID-1));
      ctx.stroke();
    }
    if(lastMove){
      ctx.fillStyle = "rgba(0,0,0,.08)";
      for(const c of [lastMove.from, lastMove.to]){
        ctx.beginPath();
        ctx.arc(toPx(c.x), toPx(c.y), 18, 0, Math.PI*2);
        ctx.fill();
      }
    }
    if(selected && !gameOver){
      ctx.fillStyle = "rgba(37,99,235,.22)";
      ctx.beginPath();
      ctx.arc(toPx(selected.x), toPx(selected.y), 24, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(37,99,235,.18)";
      for(const p of legalMoves){
        ctx.beginPath();
        ctx.arc(toPx(p.x), toPx(p.y), 14, 0, Math.PI*2);
        ctx.fill();
      }
    }
    for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
      const v = board[y][x];
      if(!v) continue;
      drawStone(x,y,v);
    }
  }

  function drawStone(x,y,color){
    const cx = toPx(x), cy = toPx(y);
    const r = 20;
    ctx.beginPath();
    ctx.arc(cx, cy, r+3, 0, Math.PI*2);
    ctx.fillStyle = "rgba(0,0,0,.10)";
    ctx.fill();
    const g = ctx.createRadialGradient(cx-7, cy-8, 4, cx, cy, r);
    const mainColor = getComputedStyle(document.documentElement).getPropertyValue(`--${color}-piece`);
    const darkColor = getComputedStyle(document.documentElement).getPropertyValue(`--${color}-piece-dark`);
    g.addColorStop(0, lightenColor(mainColor, 1.2));
    g.addColorStop(1, mainColor);
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fillStyle = g;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = darkColor;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(cx-9, cy-11, 6, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,.55)";
    ctx.fill();
  }

  function lightenColor(hex, factor){
    hex = hex.trim().replace('#', '');
    const r = parseInt(hex.slice(0,2), 16);
    const g = parseInt(hex.slice(2,4), 16);
    const b = parseInt(hex.slice(4,6), 16);
    return `rgb(${Math.min(255, Math.round(r*factor))},${Math.min(255, Math.round(g*factor))},${Math.min(255, Math.round(b*factor))})`;
  }

  // 状态文字
  function updateStatus(msg){
    if(msg){ statusEl.textContent = msg; return; }
    const who = turn==='blue' ? '蓝子' : '黑子';
    statusEl.textContent = `当前回合：${who}${isAiTurn() ? '（电脑）' : '（玩家）'}`;
  }

  // 吃子判定
  function checkCapturesOn(bd, current, afterX, afterY){
    let captured = 0;
    function checkLine(getCell,setCell){
      const occ = [];
      for(let i=0;i<GRID;i++){ const v=getCell(i); if(v) occ.push({i,v}); }
      if(occ.length !== 3) return 0;
      const my = occ.filter(o=>o.v===current).length;
      if(my !== 2) return 0;
      occ.sort((a,b)=>a.i-b.i);
      const idxs = occ.map(o=>o.i);
      if(idxs[2]-idxs[0] !== 2) return 0;
      const pat = occ.map(o=>o.v);
      const ok = (pat[0]===current && pat[1]===current && pat[2]!==current) ||
                 (pat[0]!==current && pat[1]===current && pat[2]===current);
      if(!ok) return 0;
      const eatIndex = pat[0]!==current ? idxs[0] : idxs[2];
      if(getCell(eatIndex)){ setCell(eatIndex, null); return 1; }
      return 0;
    }
    captured += checkLine(i=>bd[afterY][i], (i,v)=> bd[afterY][i]=v);
    captured += checkLine(i=>bd[i][afterX], (i,v)=> bd[i][afterX]=v);
    return captured;
  }

  function checkCaptures(afterX, afterY){
    return checkCapturesOn(board, turn, afterX, afterY);
  }

  // 胜负 & 计数
  function countPiecesOn(bd){
    let B=0,K=0;
    for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
      const v=bd[y][x];
      if(v==='blue') B++;
      else if(v==='black') K++;
    }
    return {blue:B,black:K};
  }
  function countPieces(){ return countPiecesOn(board); }

  // 游戏结束提示
  function showGameOver(winner){
    gameOver = true;
    modalMessage.innerHTML = `<h2>游戏结束！${winner}获胜！</h2>`;
    modalButtons.innerHTML = `<button onclick="closeModal();init()">重新开始</button>`;
    modal.style.display = 'flex';
  }

  function showFirstPlayerPrompt(){
    modalMessage.innerHTML = `<h2>选择先手方</h2><p>谁先下第一步棋？</p>`;
    modalButtons.innerHTML = `
      <button onclick="closeModal();init('blue')">蓝子先手</button>
      <button onclick="closeModal();init('black')">黑子先手</button>
    `;
    modal.style.display = 'flex';
  }

  function closeModal(){
    modal.style.display = 'none';
  }

  // AI 逻辑
  function allMovesFor(bd, color){
    const mv = [];
    for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
      if(bd[y][x]!==color) continue;
      for(const p of neighbors(x,y)) if(bd[p.y][p.x]===null) mv.push({from:{x,y},to:{x:p.x,y:p.y}});
    }
    return mv;
  }

  function applyMove(bd, move, color){
    const newBd = cloneBoard(bd);
    newBd[move.to.y][move.to.x] = color;
    newBd[move.from.y][move.from.x] = null;
    checkCapturesOn(newBd, color, move.to.x, move.to.y);
    return newBd;
  }

  function boardToKey(bd, color){
    return bd.map(row => row.join(',')).join('|') + '|' + color;
  }

  function evaluateBoard(bd, aiColor){
    const opponent = aiColor === 'blue' ? 'black' : 'blue';
    const cnt = countPiecesOn(bd);
    const aiPieces = cnt[aiColor];
    const oppPieces = cnt[opponent];

    if(oppPieces <= 1) return 1000000;
    if(aiPieces <= 1) return -1000000;

    let score = 0;

    // 1. 棋子数量差
    score += (aiPieces - oppPieces) * 1000;

    // 2. 吃子机会（进攻）
    const aiMoves = allMovesFor(bd, aiColor);
    let aiCapturePotential = 0;
    let aiForceTrap = 0;
    for(const move of aiMoves){
      const tmp = cloneBoard(bd);
      tmp[move.to.y][move.to.x] = aiColor;
      tmp[move.from.y][move.from.x] = null;
      const caps = checkCapturesOn(tmp, aiColor, move.to.x, move.to.y);
      aiCapturePotential += caps;
      // 检查是否迫使对手进入不利位置
      const oppMoves = allMovesFor(tmp, opponent);
      let canOppEscape = false;
      for(const oppMove of oppMoves){
        const tmp2 = applyMove(tmp, oppMove, opponent);
        if(countPiecesOn(tmp2)[aiColor] >= aiPieces) canOppEscape = true;
      }
      if(!canOppEscape && caps > 0) aiForceTrap += 1;
    }
    score += aiCapturePotential * 600;
    score += aiForceTrap * 800; // 优先迫使对手无路可走

    // 3. 防守：检测对手的吃子威胁
    const oppMoves = allMovesFor(bd, opponent);
    let oppCaptureThreat = 0;
    for(const move of oppMoves){
      const tmp = cloneBoard(bd);
      tmp[move.to.y][move.to.x] = opponent;
      tmp[move.from.y][move.from.x] = null;
      oppCaptureThreat += checkCapturesOn(tmp, opponent, move.to.x, move.to.y);
    }
    score -= oppCaptureThreat * 700;

    // 4. 机动性
    score += aiMoves.length * 100;

    // 5. 位置控制：控制关键线（中间行/列）
    const center = (GRID-1)/2;
    let keyLineControl = 0;
    for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
      if(bd[y][x] === aiColor){
        const dist = Math.abs(x - center) + Math.abs(y - center);
        score -= dist * 20;
        if(x === center || y === center) keyLineControl += 1;
      } else if(bd[y][x] === opponent){
        const dist = Math.abs(x - center) + Math.abs(y - center);
        score += dist * 10;
      }
    }
    score += keyLineControl * 200; // 控制中间行/列

    return score;
  }

  function minimax(bd, depth, alpha, beta, maximizing, aiColor, timeLimit, startTime){
    if(performance.now() - startTime > timeLimit) return evaluateBoard(bd, aiColor);
    if(depth === 0) return evaluateBoard(bd, aiColor);
    const cnt = countPiecesOn(bd);
    if(cnt[aiColor] <= 1) return -1000000;
    if(cnt[aiColor === 'blue' ? 'black' : 'blue'] <= 1) return 1000000;

    const key = boardToKey(bd, maximizing ? aiColor : (aiColor === 'blue' ? 'black' : 'blue'));
    if(transpositionTable.has(key)) return transpositionTable.get(key);

    const currentColor = maximizing ? aiColor : (aiColor === 'blue' ? 'black' : 'blue');
    const moves = allMovesFor(bd, currentColor);
    // 排序移动：优先考虑吃子和中心移动
    moves.sort((a,b) => {
      const aCaps = checkCapturesOn(applyMove(bd,a,currentColor),currentColor,a.to.x,a.to.y);
      const bCaps = checkCapturesOn(applyMove(bd,b,currentColor),currentColor,b.to.x,b.to.y);
      const aDist = Math.abs(a.to.x - 2) + Math.abs(a.to.y - 2);
      const bDist = Math.abs(b.to.x - 2) + Math.abs(b.to.y - 2);
      return (bCaps - aCaps) || (aDist - bDist);
    });

    if(maximizing){
      let maxEval = -Infinity;
      for(const move of moves){
        const newBd = applyMove(bd, move, currentColor);
        const evalScore = minimax(newBd, depth-1, alpha, beta, false, aiColor, timeLimit, startTime);
        maxEval = Math.max(maxEval, evalScore);
        alpha = Math.max(alpha, evalScore);
        if(beta <= alpha) break;
      }
      transpositionTable.set(key, maxEval);
      return maxEval;
    } else {
      let minEval = Infinity;
      for(const move of moves){
        const newBd = applyMove(bd, move, currentColor);
        const evalScore = minimax(newBd, depth-1, alpha, beta, true, aiColor, timeLimit, startTime);
        minEval = Math.min(minEval, evalScore);
        beta = Math.min(beta, evalScore);
        if(beta <= alpha) break;
      }
      transpositionTable.set(key, minEval);
      return minEval;
    }
  }

  function aiPickMove(){
    const color = turn;
    const moves = allMovesFor(board, color);
    if(!moves.length) return null;

    // 迭代加深
    const startTime = performance.now();
    const timeLimit = 1000; // 1秒限制
    const cnt = countPieces();
    const maxDepth = (cnt.blue + cnt.black <= 6) ? 6 : 5;
    let bestMoves = [];
    let bestScore = -Infinity;

    for(let depth=1; depth<=maxDepth; depth++){
      if(performance.now() - startTime > timeLimit) break;
      let currentBest = null;
      let currentScore = -Infinity;
      let alpha = -Infinity;
      let beta = Infinity;

      for(const move of moves){
        const newBd = applyMove(board, move, color);
        const score = minimax(newBd, depth-1, alpha, beta, false, color, timeLimit, startTime);
        if(score > currentScore){
          currentScore = score;
          currentBest = move;
          bestMoves = [move];
        } else if(score === currentScore){
          bestMoves.push(move);
        }
        alpha = Math.max(alpha, currentScore);
      }
      if(currentBest){
        bestScore = currentScore;
        bestMoves = bestMoves.slice(); // 保存当前深度最佳移动
      }
    }

    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
  }

  function maybeAiMove(){
    if(!isAiTurn() || gameOver) return;
    aiThinking = true;
    updateStatus('电脑思考中…');
    setTimeout(()=>{
      const mv = aiPickMove();
      if(!mv){
        aiThinking = false;
        turn = (turn==='blue') ? 'black' : 'blue';
        updateStatus('电脑无子可走');
        draw();
        return;
      }
      history.push(structuredClone({board, turn, lastMove}));
      set(mv.to.x, mv.to.y, turn);
      set(mv.from.x, mv.from.y, null);
      lastMove = {from: mv.from, to: mv.to};
      const eaten = checkCaptures(mv.to.x, mv.to.y);

      const cnt = countPieces();
      if(cnt.blue <= 1 || cnt.black <= 1){
        draw();
        showGameOver(cnt.blue <= 1 ? '黑子' : '蓝子');
        aiThinking = false;
        return;
      }
      turn = (turn==='blue') ? 'black' : 'blue';
      aiThinking = false;
      draw();
      updateStatus(eaten ? `电脑吃掉你${eaten}子！` : undefined);
      maybeAiMove();
    }, 500);
  }

  // 交互：点击
  canvas.addEventListener('click', (evt)=>{
    if(aiThinking || gameOver) return;
    const rect = canvas.getBoundingRect();
    const sx = (evt.clientX - rect.left) * (canvas.width/rect.width) / DPR;
    const sy = (evt.clientY - rect.top) * (canvas.height/rect.height) / DPR;
    const x = fromPx(sx), y = fromPx(sy);
    if(!inBoard(x,y)) return;

    const cell = get(x,y);

    if(cell === turn && !isAiTurn()){
      selected = {x,y};
      legalMoves = computeLegal(x,y);
      draw();
      updateStatus();
      return;
    }

    if(selected && !isAiTurn() && legalMoves.some(p=>p.x===x && p.y===y)){
      history.push(structuredClone({board, turn, lastMove}));
      set(x,y, turn);
      set(selected.x, selected.y, null);
      lastMove = { from:{...selected}, to:{x,y} };
      const eaten = checkCaptures(x,y);

      const cnt = countPieces();
      if(cnt.blue <= 1 || cnt.black <= 1){
        draw();
        showGameOver(cnt.blue <= 1 ? '黑子' : '蓝子');
        return;
      }

      turn = (turn==='blue') ? 'black' : 'blue';
      selected = null;
      legalMoves = [];
      draw();
      updateStatus(eaten ? `吃掉对方${eaten}子！` : undefined);
      maybeAiMove();
      return;
    }

    selected = null;
    legalMoves = [];
    draw();
    updateStatus();
  });

  // 控件
  document.getElementById('restart').addEventListener('click', showFirstPlayerPrompt);
  document.getElementById('undo').addEventListener('click', ()=>{
    if(aiThinking || !history.length || gameOver) return;
    const prev = history.pop();
    board = structuredClone(prev.board);
    turn = prev.turn;
    lastMove = prev.lastMove;
    selected = null;
    legalMoves = [];
    draw();
    updateStatus('已悔一步');
    maybeAiMove();
  });
  modeSel.addEventListener('change', ()=>{
    updateStatus();
    maybeAiMove();
  });

  // 启动
  init();
})();
</script>
</body>
</html>
