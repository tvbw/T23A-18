<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>石子棋 - 在线博弈</title>
<style>
  :root { --size: 640px; }
  body{margin:0;background:#f7f8fb;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"PingFang SC","Noto Sans CJK SC","Microsoft YaHei",sans-serif;color:#111;display:grid;place-items:center;min-height:100vh;padding:16px}
  .card{width:min(100%,760px);background:#fff;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.08);padding:16px}
  .head{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  h1{font-size:20px;margin:0}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button,select{padding:10px 14px;border-radius:12px;border:1px solid #e5e7eb;background:#fff;font-weight:600;cursor:pointer}
  button.primary{background:#111;color:#fff;border-color:#111}
  button:disabled{opacity:.5;cursor:not-allowed}
  #status{margin:10px 0 14px;font-size:14px;color:#333}
  .board-wrap{border:1px solid #eceef5;border-radius:12px;padding:10px;background:#fbfbfd}
  canvas{width:var(--size);height:var(--size);display:block;border-radius:10px;background:#fff;margin:auto}
  .legend{display:flex;gap:14px;align-items:center;margin-top:10px;font-size:13px;color:#555}
  .dot{width:14px;height:14px;border-radius:50%;display:inline-block;border:2px solid #0002}
  .blue{background:#2563eb;border-color:#1e3a8a}
  .black{background:#111;border-color:#000}
</style>
</head>
<body>
  <div class="card">
    <div class="head">
      <h1>石子棋（4×4格 · 5×5交点）</h1>
      <div class="controls">
        <button id="restart" class="primary">重新开始</button>
        <button id="undo">悔棋</button>
        <select id="mode" title="对弈模式">
          <option value="hvh">双人对战</option>
          <option value="blue-ai" selected>电脑执蓝</option>
          <option value="black-ai">电脑执黑</option>
        </select>
      </div>
    </div>
    <div id="status"></div>
    <div class="board-wrap">
      <canvas id="board" aria-label="石子棋棋盘" role="img"></canvas>
    </div>
    <div class="legend">
      <span><span class="dot blue"></span> 蓝子（默认在最上横线）</span>
      <span><span class="dot black"></span> 黑子（默认在最下横线）</span>
    </div>
  </div>

<script>
(function(){
  // ===== 棋盘参数 =====
  const GRID = 5;              // 交点数（5x5 => 4x4格）
  const CELL = 120;            // 交点间距（逻辑像素）
  const PAD  = 40;             // 边距
  const SIZE = PAD*2 + CELL*(GRID-1);

  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');

  // 让高 DPI 屏幕清晰：使用 devicePixelRatio
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width  = Math.round(SIZE * DPR);
  canvas.height = Math.round(SIZE * DPR);
  canvas.style.width  = SIZE + "px";
  canvas.style.height = SIZE + "px";
  ctx.scale(DPR, DPR);

  // 颜色 & UI
  const modeSel = document.getElementById('mode');
  const statusEl = document.getElementById('status');

  // ===== 状态 =====
  // board[y][x] = null | 'blue' | 'black'
  let board, turn, selected=null, legalMoves=[], lastMove=null, aiThinking=false;
  const history = [];

  // ===== 工具函数 =====
  const inBoard = (x,y)=> x>=0 && y>=0 && x<GRID && y<GRID;
  const get = (x,y)=> board[y][x];
  const set = (x,y,v)=> { board[y][x]=v; };
  const toPx = c => PAD + c*CELL;
  const clamp = (v,min,max)=> Math.max(min,Math.min(max,v));
  function fromPx(p){ return clamp(Math.round((p - PAD)/CELL), 0, GRID-1); }
  const neighbors = (x,y)=> [{x:x+1,y},{x:x-1,y},{x,y:y+1},{x,y:y-1}].filter(p=>inBoard(p.x,p.y));
  const computeLegal = (x,y)=> neighbors(x,y).filter(p=> get(p.x,p.y)===null );

  const isAiTurn = ()=> (modeSel.value==='blue-ai' && turn==='blue') || (modeSel.value==='black-ai' && turn==='black');

  // ===== 初始化 =====
  function init(){
    board = Array.from({length:GRID},()=>Array(GRID).fill(null));
    // 顶线放蓝子（y=0），底线放黑子（y=4），符合你的描述
    for(let x=0;x<GRID;x++){
      board[0][x] = 'blue';
      board[GRID-1][x] = 'black';
    }
    turn = 'blue'; selected=null; legalMoves=[]; lastMove=null; aiThinking=false;
    history.length = 0;
    draw(); updateStatus();
    maybeAiMove();
  }

  // ===== 绘制 =====
  function draw(){
    // 背景
    ctx.clearRect(0,0,SIZE,SIZE);
    ctx.fillStyle = "#fff"; ctx.fillRect(0,0,SIZE,SIZE);

    // 网格
    ctx.strokeStyle = "#111"; ctx.lineWidth = 2; ctx.lineCap="round";
    for(let i=0;i<GRID;i++){
      // 横线
      ctx.beginPath();
      ctx.moveTo(toPx(0), toPx(i));
      ctx.lineTo(toPx(GRID-1), toPx(i));
      ctx.stroke();
      // 竖线
      ctx.beginPath();
      ctx.moveTo(toPx(i), toPx(0));
      ctx.lineTo(toPx(i), toPx(GRID-1));
      ctx.stroke();
    }

    // 上一步高亮
    if(lastMove){
      ctx.fillStyle = "rgba(0,0,0,.08)";
      for(const c of [lastMove.from, lastMove.to]){
        ctx.beginPath();
        ctx.arc(toPx(c.x), toPx(c.y), 18, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // 选中提示 + 合法落点
    if(selected){
      ctx.fillStyle = "rgba(37,99,235,.22)";
      ctx.beginPath();
      ctx.arc(toPx(selected.x), toPx(selected.y), 24, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(37,99,235,.18)";
      for(const p of legalMoves){
        ctx.beginPath();
        ctx.arc(toPx(p.x), toPx(p.y), 14, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // 棋子
    for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
      const v = board[y][x]; if(!v) continue;
      drawStone(x,y,v);
    }
  }

  function drawStone(x,y,color){
    const cx = toPx(x), cy = toPx(y);
    const r = 20;
    // 阴影
    ctx.beginPath();
    ctx.arc(cx, cy, r+3, 0, Math.PI*2);
    ctx.fillStyle = "rgba(0,0,0,.10)";
    ctx.fill();
    // 主体渐变
    const g = ctx.createRadialGradient(cx-7, cy-8, 4, cx, cy, r);
    if(color==='blue'){ g.addColorStop(0,"#69a9ff"); g.addColorStop(1,"#2563eb"); }
    else { g.addColorStop(0,"#444"); g.addColorStop(1,"#111"); }
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fillStyle = g; ctx.fill();
    // 边
    ctx.lineWidth = 2; ctx.strokeStyle = color==='blue' ? "#1e3a8a" : "#000";
    ctx.stroke();
    // 高光
    ctx.beginPath();
    ctx.arc(cx-9, cy-11, 6, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,.55)";
    ctx.fill();
  }

  // ===== 状态文字 =====
  function updateStatus(msg){
    if(msg){ statusEl.textContent = msg; return; }
    const who = turn==='blue' ? '蓝子' : '黑子';
    statusEl.textContent = `当前回合：${who}${isAiTurn() ? '（电脑）' : '（玩家）'}`;
  }

  // ===== 吃子判定 =====
  function checkCaptures(afterX, afterY){
    return checkCapturesOn(board, turn, afterX, afterY);
  }

  // 在任意棋盘上复用的吃子判定
  function checkCapturesOn(bd, current, afterX, afterY){
    let captured = 0;
    function checkLine(getCell,setCell){
      const occ = [];
      for(let i=0;i<GRID;i++){ const v=getCell(i); if(v) occ.push({i,v}); }
      if(occ.length !== 3) return 0;             // 整条线仅 3 子
      const my = occ.filter(o=>o.v===current).length;
      if(my !== 2) return 0;                      // 必须己方 2 子 + 敌方 1 子
      occ.sort((a,b)=>a.i-b.i);
      const idxs = occ.map(o=>o.i);
      if(idxs[2]-idxs[0] !== 2) return 0;         // 必须紧邻的三个交点
      const pat = occ.map(o=>o.v);
      const ok = (pat[0]===current && pat[1]===current && pat[2]!==current) ||
                 (pat[0]!==current && pat[1]===current && pat[2]===current);
      if(!ok) return 0;
      const eatIndex = pat[0]!==current ? idxs[0] : idxs[2];
      if(getCell(eatIndex)){ setCell(eatIndex, null); return 1; }
      return 0;
    }
    captured += checkLine(i=>bd[afterY][i], (i,v)=> bd[afterY][i]=v); // 横
    captured += checkLine(i=>bd[i][afterX], (i,v)=> bd[i][afterX]=v); // 竖
    return captured;
  }

  // ===== 胜负判定 =====
  function countPieces(){ let B=0,K=0; for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){ const v=board[y][x]; if(v==='blue')B++; else if(v==='black')K++; } return {blue:B,black:K}; }
  function countPiecesOn(bd){ let B=0,K=0; for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){ const v=bd[y][x]; if(v==='blue')B++; else if(v==='black')K++; } return {blue:B,black:K}; }

  // ===== 交互：点击 =====
  canvas.addEventListener('click', (evt)=>{
    if(aiThinking) return;
    const rect = canvas.getBoundingClientRect();
    const sx = (evt.clientX - rect.left) * (canvas.width/rect.width) / DPR;
    const sy = (evt.clientY - rect.top)  * (canvas.height/rect.height) / DPR;
    const x = fromPx(sx), y = fromPx(sy);
    if(!inBoard(x,y)) return;

    const cell = get(x,y);

    // 选己方子
    if(cell === turn && !isAiTurn()){
      selected = {x,y};
      legalMoves = computeLegal(x,y);
      draw(); updateStatus(); return;
    }

    // 若已有选中且点到合法落点 => 落子
    if(selected && !isAiTurn() && legalMoves.some(p=>p.x===x && p.y===y)){
      history.push(structuredClone({board, turn, lastMove}));
      set(x,y, turn); set(selected.x, selected.y, null);
      lastMove = { from:{...selected}, to:{x,y} };
      const eaten = checkCaptures(x,y);

      const cnt = countPieces();
      if(cnt.blue<=1 || cnt.black<=1){
        draw(); updateStatus(`${cnt.blue<=1 ? '黑子' : '蓝子'}获胜！`); return;
      }

      turn = (turn==='blue') ? 'black' : 'blue';
      selected = null; legalMoves = [];
      draw(); updateStatus(eaten?`吃掉对方${eaten}子！`:undefined);
      maybeAiMove();
      return;
    }

    // 点击空白/非法：取消选择
    selected = null; legalMoves = [];
    draw(); updateStatus();
  });

  // ===== AI（启发式） =====
  const cloneBoard = (bd)=> bd.map(r=>r.slice());
  function allMovesFor(bd, color){
    const mv=[]; for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
      if(bd[y][x]!==color) continue;
      for(const p of neighbors(x,y)) if(bd[p.y][p.x]===null) mv.push({from:{x,y},to:{x:p.x,y:p.y}});
    } return mv;
  }
  function checkCapturesOnCopy(bd,color,move){
    const tmp = cloneBoard(bd);
    tmp[move.to.y][move.to.x]=color; tmp[move.from.y][move.from.x]=null;
    return checkCapturesOn(tmp, color, move.to.x, move.to.y);
  }
  function evaluateMove(bd,color,move){
    // 直接赢 > 能吃子 > 靠近中心
    const tmp = cloneBoard(bd);
    tmp[move.to.y][move.to.x]=color; tmp[move.from.y][move.from.x]=null;
    const caps = checkCapturesOn(tmp,color,move.to.x,move.to.y);
    const cnt = countPiecesOn(tmp);
    const my = color==='blue'?cnt.blue:cnt.black;
    const opp = color==='blue'?cnt.black:cnt.blue;
    if(opp<=1) return 1e6; // 胜局
    const c = (GRID-1)/2;
    const dist = Math.abs(move.to.x-c)+Math.abs(move.to.y-c);
    return caps*100 - dist; // 简单启发
  }
  function aiPickMove(){
    const color = turn;
    const moves = allMovesFor(board, color);
    if(!moves.length) return null;
    // 优先：任一能直接吃子的走法
    const capturers = moves.filter(m=> checkCapturesOnCopy(board,color,m)>0 );
    const pool = capturers.length ? capturers : moves;
    let best=null, bestScore=-Infinity;
    for(const m of pool){
      const s = evaluateMove(board,color,m);
      if(s>bestScore || (s===bestScore && Math.random()<0.5)){ bestScore=s; best=m; }
    }
    return best;
  }
  function maybeAiMove(){
    if(!isAiTurn()) return;
    aiThinking = true; updateStatus('电脑思考中…');
    setTimeout(()=>{
      const mv = aiPickMove();
      if(!mv){ aiThinking=false; turn=(turn==='blue')?'black':'blue'; updateStatus('电脑无子可走'); draw(); return; }
      history.push(structuredClone({board, turn, lastMove}));
      set(mv.to.x, mv.to.y, turn); set(mv.from.x, mv.from.y, null);
      lastMove = {from: mv.from, to: mv.to};
      const eaten = checkCaptures(mv.to.x, mv.to.y);

      const cnt = countPieces();
      if(cnt.blue<=1 || cnt.black<=1){
        draw(); updateStatus(`${cnt.blue<=1 ? '黑子' : '蓝子'}获胜！`); aiThinking=false; return;
      }
      turn = (turn==='blue') ? 'black' : 'blue';
      aiThinking=false; draw(); updateStatus(eaten?`电脑吃掉你${eaten}子！`:undefined);
    }, 380);
  }

  // ===== 控件 =====
  document.getElementById('restart').addEventListener('click', ()=>{
    init();
  });
  document.getElementById('undo').addEventListener('click', ()=>{
    if(aiThinking || !history.length) return;
    const prev = history.pop();
    board = structuredClone(prev.board);
    turn  = prev.turn;
    lastMove = prev.lastMove;
    selected=null; legalMoves=[];
    draw(); updateStatus('已悔一步');
    maybeAiMove();
  });
  modeSel.addEventListener('change', ()=>{
    updateStatus(); maybeAiMove();
  });

  // 启动
  init();
})();
</script>
</body>
</html>
